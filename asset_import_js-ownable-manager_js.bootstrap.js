/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkownable_demo"] = self["webpackChunkownable_demo"] || []).push([["asset_import_js-ownable-manager_js"],{

/***/ "./JSONView.js":
/*!*********************!*\
  !*** ./JSONView.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Created by richard.livingston on 18/02/2017.\n */\n\n\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\"),\n\tEE = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter);\n\n\nmodule.exports = JSONView;\nutil.inherits(JSONView, EE);\n\n\nfunction JSONView(name_, value_){\n\tvar self = this;\n\n\tEE.call(self);\n\n\tif(arguments.length < 2){\n\t\tvalue_ = name_;\n\t\tname_ = undefined;\n\t}\n\n\tvar name, value, type,\n\t\tdomEventListeners = [], children = [], expanded = false,\n\t\tedittingName = false, edittingValue = false,\n\t\tnameEditable = true, valueEditable = true;\n\n\tvar dom = {\n\t\tcontainer : document.createElement('div'),\n\t\tcollapseExpand : document.createElement('div'),\n\t\tname : document.createElement('div'),\n\t\tseparator : document.createElement('div'),\n\t\tvalue : document.createElement('div'),\n\t\tdelete : document.createElement('div'),\n\t\tchildren : document.createElement('div'),\n\t\tinsert : document.createElement('div')\n\t};\n\n\n\tObject.defineProperties(self, {\n\n\t\tdom : {\n\t\t\tvalue : dom.container,\n\t\t\tenumerable : true\n\t\t},\n\n\t\tname : {\n\t\t\tget : function(){\n\t\t\t\treturn name;\n\t\t\t},\n\n\t\t\tset : setName,\n\t\t\tenumerable : true\n\t\t},\n\n\t\tvalue : {\n\t\t\tget : function(){\n\t\t\t\treturn value;\n\t\t\t},\n\n\t\t\tset : setValue,\n\t\t\tenumerable : true\n\t\t},\n\n\t\ttype : {\n\t\t\tget : function(){\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tenumerable : true\n\t\t},\n\n\t\tnameEditable : {\n\t\t\tget : function(){\n\t\t\t\treturn nameEditable;\n\t\t\t},\n\n\t\t\tset : function(value){\n\t\t\t\tnameEditable = !!value;\n\t\t\t},\n\n\t\t\tenumerable : true\n\t\t},\n\n\t\tvalueEditable : {\n\t\t\tget : function(){\n\t\t\t\treturn valueEditable;\n\t\t\t},\n\n\t\t\tset : function(value){\n\t\t\t\tvalueEditable = !!value;\n\t\t\t},\n\n\t\t\tenumerable : true\n\t\t},\n\n\t\trefresh : {\n\t\t\tvalue : refresh,\n\t\t\tenumerable : true\n\t\t},\n\n\t\tcollapse : {\n\t\t\tvalue : collapse,\n\t\t\tenumerable : true\n\t\t},\n\n\t\texpand : {\n\t\t\tvalue : expand,\n\t\t\tenumerable : true\n\t\t},\n\n\t\tdestroy : {\n\t\t\tvalue : destroy,\n\t\t\tenumerable : true\n\t\t},\n\n\t\teditName : {\n\t\t\tvalue : editField.bind(null, 'name'),\n\t\t\tenumerable : true\n\t\t},\n\n\t\teditValue : {\n\t\t\tvalue : editField.bind(null, 'value'),\n\t\t\tenumerable : true\n\t\t}\n\n\t});\n\n\n\tObject.keys(dom).forEach(function(k){\n\t\tvar element = dom[k];\n\n\t\tif(k == 'container'){\n\t\t\treturn;\n\t\t}\n\n\t\telement.className = k;\n\t\tdom.container.appendChild(element);\n\t});\n\n\tdom.container.className = 'jsonView';\n\n\taddDomEventListener(dom.collapseExpand, 'click', onCollapseExpandClick);\n\taddDomEventListener(dom.value, 'click', expand.bind(null, false));\n\taddDomEventListener(dom.name, 'click', expand.bind(null, false));\n\n\taddDomEventListener(dom.name, 'blur', editFieldStop.bind(null, 'name'));\n\taddDomEventListener(dom.name, 'keypress', editFieldKeyPressed.bind(null, 'name'));\n\taddDomEventListener(dom.name, 'keydown', editFieldTabPressed.bind(null, 'name'));\n\n\taddDomEventListener(dom.value, 'blur', editFieldStop.bind(null, 'value'));\n\taddDomEventListener(dom.value, 'keypress', editFieldKeyPressed.bind(null, 'value'));\n\taddDomEventListener(dom.value, 'keydown', editFieldTabPressed.bind(null, 'value'));\n\taddDomEventListener(dom.value, 'keydown', numericValueKeyDown);\n\n\n\n\taddDomEventListener(dom.insert, 'click', onInsertClick);\n\taddDomEventListener(dom.delete, 'click', onDeleteClick);\n\n\tsetName(name_);\n\tsetValue(value_);\n\n\n\tfunction refresh(){\n\t\tvar expandable = type == 'object' || type == 'array';\n\n\t\tchildren.forEach(function(child){\n\t\t\tchild.refresh();\n\t\t});\n\n\t\tdom.collapseExpand.style.display = expandable ? '' : 'none';\n\n\t\tif(expanded && expandable){\n\t\t\texpand();\n\t\t}\n\t\telse{\n\t\t\tcollapse();\n\t\t}\n\t}\n\n\n\tfunction collapse(recursive){\n\t\tif(recursive){\n\t\t\tchildren.forEach(function(child){\n\t\t\t\tchild.collapse(true);\n\t\t\t});\n\t\t}\n\n\t\texpanded = false;\n\n\t\tdom.children.style.display = 'none';\n\t\tdom.collapseExpand.className = 'expand';\n\t\tdom.container.classList.add('collapsed');\n\t\tdom.container.classList.remove('expanded');\n\t}\n\n\n\tfunction expand(recursive){\n\t\tvar keys;\n\n\t\tif(type == 'object'){\n\t\t\tkeys = Object.keys(value);\n\t\t}\n\t\telse if(type == 'array'){\n\t\t\tkeys = value.map(function(v, k){\n\t\t\t\treturn k;\n\t\t\t});\n\t\t}\n\t\telse{\n\t\t\tkeys = [];\n\t\t}\n\n\t\t// Remove children that no longer exist\n\t\tfor(var i = children.length - 1; i >= 0; i --){\n\t\t\tvar child = children[i];\n\n\t\t\tif(keys.indexOf(child.name) == -1){\n\t\t\t\tchildren.splice(i, 1);\n\t\t\t\tremoveChild(child);\n\t\t\t}\n\t\t}\n\n\t\tif(type != 'object' && type != 'array'){\n\t\t\treturn collapse();\n\t\t}\n\n\t\tkeys.forEach(function(key){\n\t\t\taddChild(key, value[key]);\n\t\t});\n\n\t\tif(recursive){\n\t\t\tchildren.forEach(function(child){\n\t\t\t\tchild.expand(true);\n\t\t\t});\n\t\t}\n\n\t\texpanded = true;\n\t\tdom.children.style.display = '';\n\t\tdom.collapseExpand.className = 'collapse';\n\t\tdom.container.classList.add('expanded');\n\t\tdom.container.classList.remove('collapsed');\n\t}\n\n\n\tfunction destroy(){\n\t\tvar child, event;\n\n\t\twhile(event = domEventListeners.pop()){\n\t\t\tevent.element.removeEventListener(event.name, event.fn);\n\t\t}\n\n\t\twhile(child = children.pop()){\n\t\t\tremoveChild(child);\n\t\t}\n\t}\n\n\n\tfunction setName(newName){\n\t\tvar nameType = typeof newName,\n\t\t\toldName = name;\n\n\t\tif(newName === name){\n\t\t\treturn;\n\t\t}\n\n\t\tif(nameType != 'string' && nameType != 'number'){\n\t\t\tthrow new Error('Name must be either string or number, ' + newName);\n\t\t}\n\n\t\tdom.name.innerText = newName;\n\t\tname = newName;\n\t\tself.emit('rename', self, oldName, newName);\n\t}\n\n\n\tfunction setValue(newValue){\n\t\tvar oldValue = value,\n\t\t\tstr;\n\n\t\ttype = getType(newValue);\n\n\t\tswitch(type){\n\t\t\tcase 'null':\n\t\t\t\tstr = 'null';\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tstr = 'Object[' + Object.keys(newValue).length + ']';\n\t\t\t\tbreak;\n\n\t\t\tcase 'array':\n\t\t\t\tstr = 'Array[' + newValue.length + ']';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstr = newValue;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdom.value.innerText = str;\n\t\tdom.value.className = 'value ' + type;\n\n\t\tif(newValue === value){\n\t\t\treturn;\n\t\t}\n\n\t\tvalue = newValue;\n\n\t\tif(type == 'array' || type == 'object'){\n\t\t\t// Cannot edit objects as string because the formatting is too messy\n\t\t\t// Would have to either pass as JSON and force user to wrap properties in quotes\n\t\t\t// Or first JSON stringify the input before passing, this could allow users to reference globals\n\n\t\t\t// Instead the user can modify individual properties, or just delete the object and start again\n\t\t\tvalueEditable = false;\n\n\t\t\tif(type == 'array'){\n\t\t\t\t// Obviously cannot modify array keys\n\t\t\t\tnameEditable = false;\n\t\t\t}\n\t\t}\n\n\t\trefresh();\n\t\tself.emit('change', name, oldValue, newValue);\n\t}\n\n\n\tfunction addChild(key, val){\n\t\tvar child;\n\n\t\tfor(var i = 0, len = children.length; i < len; i ++){\n\t\t\tif(children[i].name == key){\n\t\t\t\tchild = children[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(child){\n\t\t\tchild.value = val;\n\t\t}\n\t\telse{\n\t\t\tchild = new JSONView(key, val);\n\t\t\tchild.once('rename', onChildRename);\n\t\t\tchild.on('delete', onChildDelete);\n\t\t\tchild.on('change', onChildChange);\n\t\t\tchildren.push(child);\n\t\t}\n\n\t\tdom.children.appendChild(child.dom);\n\n\t\treturn child;\n\t}\n\n\n\tfunction removeChild(child){\n\t\tif(child.dom.parentNode){\n\t\t\tdom.children.removeChild(child.dom);\n\t\t}\n\n\t\tchild.destroy();\n\t\tchild.removeAllListeners();\n\t}\n\n\n\tfunction editField(field){\n\t\tvar editable = field == 'name' ? nameEditable : valueEditable,\n\t\t\telement = dom[field];\n    console.log(\"editable: \", editable);\n\t\tif(!editable){\n\t\t\treturn;\n\t\t}\n\n\t\tif(field == 'value' && type == 'string'){\n\t\t\telement.innerText = '\"' + value + '\"';\n\t\t}\n\n\t\tif(field == 'name'){\n\t\t\tedittingName = true;\n\t\t}\n\n\t\tif(field == 'value'){\n\t\t\tedittingValue = true;\n\t\t}\n\n\t\telement.classList.add('edit');\n\t\telement.setAttribute('contenteditable', true);\n\t\telement.focus();\n\t\tdocument.execCommand('selectAll', false, null);\n\t}\n\n\n\tfunction editFieldStop(field){\n\t\tvar element = dom[field];\n\n\t\tif(field == 'name'){\n\t\t\tif(!edittingName){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tedittingName = false;\n\t\t}\n\n\t\tif(field == 'value'){\n\t\t\tif(!edittingValue){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tedittingValue = false;\n\t\t}\n\n\t\tif(field == 'name'){\n\t\t\tsetName(element.innerText);\n\t\t}\n\t\telse{\n\t\t\ttry{\n\t\t\t\tsetValue(JSON.parse(element.innerText));\n\t\t\t}\n\t\t\tcatch(err){\n\t\t\t\tsetValue(element.innerText);\n\t\t\t}\n\t\t}\n\n\t\telement.classList.remove('edit');\n\t\telement.removeAttribute('contenteditable');\n\t}\n\n\n\tfunction editFieldKeyPressed(field, e){\n\t\tswitch(e.key){\n\t\t\tcase 'Escape':\n\t\t\tcase 'Enter':\n\t\t\t\teditFieldStop(field);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tfunction editFieldTabPressed(field, e){\n\t\tif(e.key == 'Tab'){\n\t\t\teditFieldStop(field);\n\n\t\t\tif(field == 'name'){\n\t\t\t\te.preventDefault();\n\t\t\t\teditField('value');\n\t\t\t}\n\t\t\telse{\n\t\t\t\teditFieldStop(field);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction numericValueKeyDown(e){\n\t\tvar increment = 0, currentValue;\n\n\t\tif(type != 'number'){\n\t\t\treturn;\n\t\t}\n\n\t\tswitch(e.key){\n\t\t\tcase 'ArrowDown':\n\t\t\tcase 'Down':\n\t\t\t\tincrement = -1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'Up':\n\t\t\t\tincrement = 1;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(e.shiftKey){\n\t\t\tincrement *= 10;\n\t\t}\n\n\t\tif(e.ctrlKey || e.metaKey){\n\t\t\tincrement /= 10;\n\t\t}\n\n\t\tif(increment){\n\t\t\tcurrentValue = parseFloat(dom.value.innerText);\n\n\t\t\tif(!isNaN(currentValue)){\n\t\t\t\tsetValue(Number((currentValue + increment).toFixed(10)));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction getType(value){\n\t\tvar type = typeof value;\n\n\t\tif(type == 'object'){\n\t\t\tif(value === null){\n\t\t\t\treturn 'null';\n\t\t\t}\n\n\t\t\tif(Array.isArray(value)){\n\t\t\t\treturn 'array';\n\t\t\t}\n\t\t}\n\n\t\treturn type;\n\t}\n\n\n\tfunction onCollapseExpandClick(){\n\t\tif(expanded){\n\t\t\tcollapse();\n\t\t}\n\t\telse{\n\t\t\texpand();\n\t\t}\n\t}\n\n\n\tfunction onInsertClick(){\n\t\tvar newName = type == 'array' ? value.length : undefined,\n\t\t\tchild = addChild(newName, null);\n\n\t\tif(type == 'array'){\n\t\t\tvalue.push(null);\n\t\t\tchild.editValue();\n\t\t}\n\t\telse{\n\t\t\tchild.editName();\n\t\t}\n\t}\n\n\n\tfunction onDeleteClick(){\n\t\tself.emit('delete', self);\n\t}\n\n\n\tfunction onChildRename(child, oldName, newName){\n\t\tvar allow = newName && type != 'array' && !(newName in value);\n\n\t\tif(allow){\n\t\t\tvalue[newName] = child.value;\n\t\t\tdelete value[oldName];\n\t\t}\n\t\telse if(oldName === undefined){\n\t\t\t// A new node inserted via the UI\n\t\t\tremoveChild(child);\n\t\t}\n\t\telse{\n\t\t\t// Cannot rename array keys, or duplicate object key names\n\t\t\tchild.name = oldName;\n\t\t}\n\n\t\tchild.once('rename', onChildRename);\n\t}\n\n\n\tfunction onChildChange(keyPath, oldValue, newValue, recursed){\n\t\tif(!recursed){\n\t\t\tvalue[keyPath] = newValue;\n\t\t}\n\n\t\tself.emit('change', name + '.' + keyPath, oldValue, newValue, true);\n\t}\n\n\n\tfunction onChildDelete(child){\n\t\tvar key = child.name;\n\n\t\tif(type == 'array'){\n\t\t\tvalue.splice(key, 1);\n\t\t}\n\t\telse{\n\t\t\tdelete value[key];\n\t\t}\n\n\t\trefresh();\n\t}\n\n\n\tfunction addDomEventListener(element, name, fn){\n\t\telement.addEventListener(name, fn);\n\t\tdomEventListeners.push({element : element, name : name, fn : fn});\n\t}\n}\n\n\n//# sourceURL=webpack://ownable-demo/./JSONView.js?");

/***/ }),

/***/ "./asset_import.js":
/*!*************************!*\
  !*** ./asset_import.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addOwnableOption\": () => (/* binding */ addOwnableOption),\n/* harmony export */   \"associateOwnableType\": () => (/* binding */ associateOwnableType),\n/* harmony export */   \"dropFilenameExtension\": () => (/* binding */ dropFilenameExtension),\n/* harmony export */   \"fetchTemplate\": () => (/* binding */ fetchTemplate),\n/* harmony export */   \"getOwnableType\": () => (/* binding */ getOwnableType),\n/* harmony export */   \"importAssets\": () => (/* binding */ importAssets),\n/* harmony export */   \"importAvailableAssets\": () => (/* binding */ importAvailableAssets),\n/* harmony export */   \"removeOwnableOption\": () => (/* binding */ removeOwnableOption)\n/* harmony export */ });\n/* harmony import */ var _event_chain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-chain */ \"./event-chain.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jszip */ \"./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ownable_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ownable-manager */ \"./ownable-manager.js\");\n\n\n\n\nfunction importAssets() {\n\n  let input = document.createElement(\"input\");\n  input.type = \"file\";\n  input.name = \"file\";\n  input.id = \"file\";\n  input.accept = \".zip\";\n  input.multiple = true;\n  let templates = [];\n\n  input.onchange = async e => {\n    const files = e.target.files;\n    let unzippedFiles = await importZip(files);\n    for (let i = 0; i < unzippedFiles.length; i++) {\n      templates[i] = unzippedFiles[i];\n    }\n    await storeTemplates(templates);\n  }\n  input.onerror = () => console.log(\"error uploading files\");\n  input.click();\n}\n\nasync function importAvailableAssets() {\n  const ownablePaths = [\n    'antenna.zip',\n    'armor.zip',\n    'car.zip',\n    'paint.zip',\n    'robot.zip',\n    'speakers.zip',\n  ];\n\n  // await Promise.all(ownablePaths.map(path => promisifyXHRRequest(path)));\n  for (const path in ownablePaths) {\n    await promisifyXHRRequest(ownablePaths[path]);\n    // temporary fix for not blocking the idb\n    setTimeout(() => {}, 500);\n  }\n\n}\n\nfunction promisifyXHRRequest(path) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = \"arraybuffer\";\n    xhr.onreadystatechange = async () => {\n      if (xhr.readyState === 4) {\n        const zip = xhr.response;\n        zip.name = path;\n        await unzipAndStore(zip);\n        resolve();\n      }\n    }\n    xhr.open(\"GET\", `ownables/${path}`, true);\n    xhr.send();\n  });\n}\n\nasync function unzipAndStore(ownablePackage) {\n  let unzippedFiles = await importZipBlob(ownablePackage);\n  await storeTemplates(unzippedFiles);\n}\n\nconst extToMimes = {\n  '.img': 'image/jpeg',\n  '.png': 'image/png',\n  '.svg': 'image/svg',\n  '.html': 'text/html',\n  '.js': 'text/javascript',\n  '.mjs': 'text/javascript',\n  '.wasm': 'application/wasm',\n  '.mp4': 'video/mp4',\n}\n\nasync function importZip(f) {\n  let files = [];\n\n  await jszip__WEBPACK_IMPORTED_MODULE_1___default().loadAsync(f[0])\n    .then(async function (zip) {\n      for (let [filename, file] of Object.entries(zip.files)) {\n        if (!filename.includes(\"MAC\")) {\n          const blob = await zip.files[filename].async(\"blob\");\n          const ext = filename.substring(filename.indexOf('.'));\n          files.push(new File([blob], filename, {\n            type: extToMimes[ext]\n          }));\n        }\n      }\n    }, function (e) {\n        console.log(\"error reading\")\n    }\n  );\n  return files;\n}\n\nasync function importZipBlob(f) {\n  let files = [];\n\n  await jszip__WEBPACK_IMPORTED_MODULE_1___default().loadAsync(f)\n    .then( async function (zip) {\n      for (let [filename, file] of Object.entries(zip.files)) {\n          if (!filename.includes(\"MAC\")) {\n            const blob = await zip.files[filename].async(\"blob\");\n            const ext = filename.substring(filename.indexOf('.'));\n            files.push(new File([blob], filename, {\n              type: extToMimes[ext]\n            }));\n          }\n        }\n      }, function (e) {\n        console.log(\"error reading\")\n      }\n    );\n  return files;\n}\n\nfunction storeTemplates(templates) {\n  return new Promise((resolve, reject) => {\n    console.log(\"unwrapping templates: \", templates);\n    let templateFile = templates.find(t => t.type === extToMimes[\".html\"]);\n    let templateName = dropFilenameExtension(templateFile.name);\n    console.log(`template name: ${templateName}`);\n    let newImport = false;\n    let db;\n    const templateCount = JSON.parse(localStorage.templates).length;\n\n    const request = window.indexedDB.open(_event_chain__WEBPACK_IMPORTED_MODULE_0__.ASSETS_STORE, templateCount + 1);\n    request.onupgradeneeded = (e) => {\n      db = request.result;\n      // if template is being replaced, cleanup the storage\n      if (db.objectStoreNames.contains(templateName)) {\n        let templates = JSON.parse(localStorage.getItem(\"templates\"));\n        templates = templates.filter(template => template != templateName);\n        localStorage.setItem(\"templates\", JSON.stringify(templates));\n\n        for (const key in localStorage) {\n          let val = localStorage[key];\n          if (val === templateName) {\n            console.log('removing ', templateName);\n            // association ownableId->type\n            localStorage.removeItem(val);\n            // also remove from chainIds\n            let chainIds = JSON.parse(localStorage.getItem(\"chainIds\"));\n            chainIds = chainIds.filter(id => id != key);\n            localStorage.setItem(\"chainIds\", JSON.stringify(chainIds));\n            // removeOwnableOption(templateName);\n            db.deleteObjectStore(templateName);\n            // TODO: remove indexdb entry of ownable?\n          }\n        }\n      }\n      db.createObjectStore(templateName);\n    };\n    request.onsuccess = async () => {\n      db = request.result;\n\n      for (let i = 0; i < templates.length; i++) {\n        await writeTemplate(db, templateName, templates[i]);\n      }\n      const templateOptions = JSON.parse(localStorage.templates);\n      templateOptions.push(templateName);\n      localStorage.templates = JSON.stringify(templateOptions);\n      await addOwnableOption(templateName);\n\n\n      console.log(\"templates stored\");\n      db.close();\n      resolve();\n    }\n    request.onblocked = (event) => {\n      db.close();\n      reject(\"idb blocked: \", event);\n    }\n    request.onerror = (event) => { console.log(event); reject(\"failed to open indexeddb: \", event); }\n  });\n\n}\n\nasync function addOwnableOption(templateName) {\n  let ownableHtml = document.createElement(\"button\");\n  ownableHtml.id = `inst-${templateName}`;\n  ownableHtml.innerText = templateName;\n  ownableHtml.type = \"button\";\n  ownableHtml.addEventListener('click', async () => {\n    document.getElementById(\"inst-menu\").classList.toggle(\"show\");\n    await (0,_ownable_manager__WEBPACK_IMPORTED_MODULE_2__.createNewOwnable)(templateName);\n  });\n  document.getElementById(\"inst-menu\").appendChild(ownableHtml);\n}\n\nasync function removeOwnableOption(templateName) {\n  let ownableHtml = document.getElementById(`inst-${templateName}`);\n  ownableHtml.remove();\n}\n\nfunction writeTemplate(db, ownableType, template) {\n  return new Promise(async (resolve, reject) => {\n    let templateName;\n    switch (template.type) {\n      case \"application/wasm\":\n        templateName = \"wasm\";\n        break;\n      case \"text/html\":\n        templateName = \"html\";\n        break;\n      case \"text/javascript\":\n        templateName = template.name;\n        break;\n      default:\n        templateName = template[\"name\"];\n        break;\n    }\n    let tx = db\n      .transaction(ownableType, \"readwrite\")\n      .objectStore(ownableType)\n      .put(template, templateName);\n    tx.onsuccess = () => resolve(tx.result);\n    tx.onerror = (err) => reject(err);\n    tx.onblocked = (err) => reject(err);\n  });\n}\n\n\n\n// function appendWorkerGlueCode(templateName) {\n//   return new Promise((resolve, reject) => {\n//     let db, template;\n//     const request = window.indexedDB.open(ASSETS_STORE);\n//     request.onsuccess = async () => {\n//       db = request.result;\n//       let templateTx = db.transaction(templateName, \"readonly\")\n//         .objectStore(templateName)\n//         .get(\"bindgen.js\");\n//       templateTx.onsuccess = () => {\n//         template = templateTx.result;\n//         const fr = new FileReader();\n//         fr.onload = async () => {\n//           let bindgenDataURL = fr.result;\n//           let workerDataURL = await readWorkerGlueAsDataURL();\n//           // append the worker glue code to bindgen glue code\n//           let combinedDataURL = joinDataURLContents(bindgenDataURL, workerDataURL);\n//           console.log(combinedDataURL);\n//           let newTemplate = new File([combinedDataURL], template.name, { type: template.type });\n//           let updateTemplateTx = db.transaction(templateName, \"readwrite\")\n//             .objectStore(templateName)\n//             .put(newTemplate, \"bindgen.js\");\n//           updateTemplateTx.onsuccess = () => {\n//             resolve(updateTemplateTx.result);\n//           };\n//         };\n//         if (template) {\n//           console.log(\"reading template data url\");\n//           fr.readAsDataURL(template);\n//         } else {\n//           reject();\n//         }\n//       }\n//     }\n//   });\n// }\n//\n\nfunction readWorkerGlueAsDataURL() {\n  return new Promise(async (resolve, reject) => {\n    let fr = new FileReader();\n    fr.onload = async (event) => {\n      resolve(fr.result);\n    };\n    let glueFile = await fetch(\"worker.js\");\n    fr.readAsDataURL(await glueFile.blob());\n  });\n}\n\nfunction joinDataURLContents(first, second) {\n  const dataURLPrefix = 'data:text/javascript;base64,';\n  let firstSplit = first.split('base64,');\n  let secondSplit = second.split('base64,');\n  let joinedContents = atob(firstSplit[1]) + atob(secondSplit[1]);\n  let joinedB64 = btoa(joinedContents);\n  return dataURLPrefix + joinedB64;\n}\n\n\nfunction dropFilenameExtension(filename) {\n  return filename.substring(0, filename.indexOf(\".\"));\n}\n\nfunction fetchTemplate(db, key, objectStore) {\n  return new Promise((resolve, reject) => {\n    let tx = db.transaction(objectStore, \"readonly\")\n      .objectStore(objectStore)\n      .get(key);\n\n    tx.onsuccess = () => resolve(tx.result);\n    tx.onerror = (err) => reject(err);\n    tx.onblocked = (err) => reject(err);\n  });\n}\n\nfunction associateOwnableType(db, ownableId, ownableType) {\n  return new Promise((resolve, reject) => {\n    let tx = db.transaction(\"associations\", \"readwrite\")\n      .objectStore(\"associations\")\n      .put(ownableType, ownableId);\n\n    tx.onsuccess = () => resolve(tx.result);\n    tx.onerror = (err) => reject(err);\n    tx.onblocked = (err) => reject(err);\n  });\n}\n\nfunction getOwnableType(ownableId) {\n  return new Promise((resolve, reject) => {\n    let dbTx = indexedDB.open(ownableId);\n    dbTx.onsuccess = (e) => {\n      let db = e.target.result;\n      let tx = db.transaction(\"associations\", \"readwrite\")\n        .objectStore(\"associations\")\n        .get(ownableId);\n      tx.onsuccess = () => {\n        db.close();\n        resolve(tx.result);\n      }\n      tx.onerror = () => {\n        db.close();\n        reject();\n      }\n    }\n    dbTx.onblocked = () => reject(\"db blocked\");\n    dbTx.onerror = () => reject(\"failed to open db\");\n  });\n}\n\n\n//# sourceURL=webpack://ownable-demo/./asset_import.js?");

/***/ }),

/***/ "./event-chain.js":
/*!************************!*\
  !*** ./event-chain.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASSETS_STORE\": () => (/* binding */ ASSETS_STORE),\n/* harmony export */   \"anchorEventToChain\": () => (/* binding */ anchorEventToChain),\n/* harmony export */   \"deleteIndexedDb\": () => (/* binding */ deleteIndexedDb),\n/* harmony export */   \"getLatestChain\": () => (/* binding */ getLatestChain),\n/* harmony export */   \"initIndexedDb\": () => (/* binding */ initIndexedDb),\n/* harmony export */   \"validateIndexedDBSupport\": () => (/* binding */ validateIndexedDBSupport),\n/* harmony export */   \"writeInstantiatedChainToIdb\": () => (/* binding */ writeInstantiatedChainToIdb),\n/* harmony export */   \"writeLatestChain\": () => (/* binding */ writeLatestChain)\n/* harmony export */ });\n/* harmony import */ var _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ltonetwork/lto/lib/events */ \"./node_modules/@ltonetwork/lto/lib/events/index.js\");\n/* harmony import */ var _ltonetwork_lto_lib_transactions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ltonetwork/lto/lib/transactions */ \"./node_modules/@ltonetwork/lto/lib/transactions/index.js\");\n\n\n\nconst EVENTS_STORE = \"events\";\nconst CHAIN_STORE = \"chain\";\nconst STATE_STORE = \"state\";\nconst ASSETS_STORE = \"assets\";\nconst READ_WRITE = \"readwrite\";\nconst LATEST = \"latest\";\n\nfunction validateIndexedDBSupport() {\n  if (!window.indexedDB) {\n    console.log(\"Your browser doesn't support a stable version of IndexedDB.\");\n  }\n}\n\nfunction getLatestChain(ownable_id) {\n  validateIndexedDBSupport();\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(ownable_id);\n    request.onsuccess = async () => {\n      const db = request.result;\n      const latestEventChainHash = await promisifyIdbGetTxn(db, CHAIN_STORE, LATEST);\n      const currentChainJSON = await promisifyIdbGetTxn(db, EVENTS_STORE, latestEventChainHash);\n      const eventChain = _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__.EventChain.from(currentChainJSON);\n      db.close();\n      resolve(eventChain);\n    };\n    request.onerror = (e) => reject(e);\n  });\n}\n\nfunction writeLatestChain(ownable_id, chain) {\n  validateIndexedDBSupport();\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(ownable_id);\n    request.onsuccess = async () => {\n      const db = request.result;\n      await promisifyIdbPutTxn(db, EVENTS_STORE, chain.id, chain.toJSON());\n      await promisifyIdbPutTxn(db, CHAIN_STORE, LATEST, chain.id);\n      db.close();\n      resolve(chain);\n    };\n    request.onerror = (e) => reject(e);\n  });\n}\n\nasync function anchorEventToChain(chain, event, node, account) {\n  const addedEvent = event.addTo(chain).signWith(account);\n  return await new _ltonetwork_lto_lib_transactions__WEBPACK_IMPORTED_MODULE_1__.MappedAnchor(chain.startingWith(addedEvent).anchorMap)\n    .signWith(account)\n    .broadcastTo(node);\n}\n\nasync function writeInstantiatedChainToIdb(db, chain) {\n  await promisifyIdbPutTxn(db, EVENTS_STORE, chain.id, chain.toJSON());\n  await promisifyIdbPutTxn(db, CHAIN_STORE, LATEST, chain.id);\n  await promisifyIdbPutTxn(db, CHAIN_STORE, \"network\", chain.networkId);\n}\n\nfunction promisifyIdbPutTxn(db, store, key, val) {\n  return new Promise((resolve, reject) => {\n    const objectStore = db.transaction(store, READ_WRITE).objectStore(store);\n    let txn = objectStore.put(val, key);\n    txn.onsuccess = () => resolve(key);\n    txn.onerror = (e) => reject(e);\n  });\n}\n\nfunction promisifyIdbGetTxn(db, store, key) {\n  return new Promise((resolve, reject) => {\n    const objectStore = db.transaction(store, READ_WRITE).objectStore(store);\n    let txn = objectStore.get(key);\n    txn.onsuccess = () => resolve(txn.result);\n    txn.onerror = (e) => reject(e);\n  });\n}\n\nfunction deleteIndexedDb(name) {\n  return new Promise((resolve, reject) => {\n    validateIndexedDBSupport();\n    const chainIds = JSON.parse(localStorage.chainIds);\n    const index = chainIds.indexOf(name);\n    if (index !== -1) {\n      chainIds.splice(index, 1);\n    }\n    localStorage.chainIds = JSON.stringify(chainIds);\n    const request = window.indexedDB.deleteDatabase(name);\n\n    request.onerror = () => reject(\"error deleting idb\");\n    request.onsuccess = () => {\n      console.log(\"success deleting db\");\n      resolve();\n    }\n    request.onblocked = (e) => reject(\"idb blocked: \", e);\n  });\n}\n\nfunction initIndexedDb(ownable_id) {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(ownable_id);\n    let db;\n    request.onupgradeneeded = () => {\n      db = request.result;\n      if (!db.objectStoreNames.contains(EVENTS_STORE)) {\n        db.createObjectStore(EVENTS_STORE);\n      }\n      if (!db.objectStoreNames.contains(CHAIN_STORE)) {\n        db.createObjectStore(CHAIN_STORE);\n      }\n      if (!db.objectStoreNames.contains(STATE_STORE)) {\n        db.createObjectStore(STATE_STORE);\n      }\n      if (!db.objectStoreNames.contains(\"associations\")) {\n        db.createObjectStore(\"associations\");\n      }\n    }\n    request.onsuccess = () => {\n      db = request.result;\n      resolve(db);\n    }\n    request.onerror = (event) => reject('failed to open indexeddb: ' + event.errorCode);\n    request.onblocked = (event) => reject(\"idb blocked: \" + event)\n  });\n}\n\n\n//# sourceURL=webpack://ownable-demo/./event-chain.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOwnableInfo\": () => (/* binding */ getOwnableInfo)\n/* harmony export */ });\n/* harmony import */ var _ownable_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ownable-manager */ \"./ownable-manager.js\");\n/* harmony import */ var _asset_import__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset_import */ \"./asset_import.js\");\n/* harmony import */ var _event_chain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event-chain */ \"./event-chain.js\");\n/* harmony import */ var _JSONView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./JSONView */ \"./JSONView.js\");\n/* harmony import */ var _JSONView__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_JSONView__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n// if no chainIds found, init empty\nif (localStorage.getItem(\"chainIds\") === null) {\n  localStorage.chainIds = JSON.stringify([]);\n}\nif (localStorage.getItem(\"templates\") === null) {\n  localStorage.templates = JSON.stringify([]);\n} else {\n  let templates = JSON.parse(localStorage.getItem(\"templates\"));\n  templates.forEach(\n    t => (0,_asset_import__WEBPACK_IMPORTED_MODULE_1__.addOwnableOption)(t)\n  );\n}\n\nconst eventType = {\n  TRANSFER: \"transfer\",\n  DELETE: \"delete\",\n  EXECUTE: \"execute\",\n  EXTERNAL_EVENT: \"external_event\",\n  INFO: \"info\",\n};\n\n\ndocument.getElementById(\"inst\").addEventListener('click', async event => {\n  event.preventDefault();\n  const modal = document.getElementById('inst-modal');\n  modal.classList.add('open');\n  const exits = modal.querySelectorAll('.modal-bg, .instantiate-selection button');\n  exits.forEach(function (exit) {\n    exit.addEventListener('click', function (event) {\n      event.preventDefault();\n      modal.classList.remove('open');\n    });\n  });\n});\n\ndocument.getElementsByClassName(\"import-button\")[0].addEventListener('click', () => (0,_asset_import__WEBPACK_IMPORTED_MODULE_1__.importAssets)());\ndocument.getElementsByClassName(\"import-all-button\")[0].addEventListener('click', () => (0,_asset_import__WEBPACK_IMPORTED_MODULE_1__.importAvailableAssets)());\nsetTimeout(async () => {\n  if (localStorage.templates) {\n    await (0,_ownable_manager__WEBPACK_IMPORTED_MODULE_0__.syncDb)();\n  }\n}, 0);\n\ndocument.getElementById(\"reset\").addEventListener('click', async event => {\n  event.preventDefault();\n  if (!window.confirm(\"Are you sure you want to reset your environment? This is a destructive action.\")) return;\n\n  // clean session\n  for (const key in localStorage) {\n    if (key !== \"encryptedSeed\" && key !== \"templates\") {\n      localStorage.removeItem(key);\n    }\n  }\n  window.indexedDB.databases().then((r) => {\n    for (var i = 0; i < r.length; i++) {\n      console.log(r[i]);\n      if (r[i].name !== \"assets\") {\n        window.indexedDB.deleteDatabase(r[i].name);\n      }\n    }\n  }).then(() => {\n    console.log('all cleared');\n    window.location.reload();\n  });\n});\n\nwindow.addEventListener(\"message\", async event => {\n  if (typeof event.data.ownable_id === \"undefined\") return;\n  if (document.getElementById(event.data.ownable_id).contentWindow !== event.source) {\n    throw Error(\"Not allowed to execute msg on other ownable\");\n  }\n  console.log(\"processing message: \", event);\n  switch (event.data.type) {\n    case eventType.EXECUTE:\n      await (0,_ownable_manager__WEBPACK_IMPORTED_MODULE_0__.executeOwnable)(event.data.ownable_id, event.data.msg);\n      break;\n    case eventType.EXTERNAL_EVENT:\n      await (0,_ownable_manager__WEBPACK_IMPORTED_MODULE_0__.registerExternalEvent)(event.data.ownable_id, event.data.externalEvent);\n      break;\n    default:\n      console.log(\"unknown msg: \", event.data.type);\n      break;\n  }\n});\n\nasync function getOwnableInfo(ownable_id) {\n  let metadata = await (0,_ownable_manager__WEBPACK_IMPORTED_MODULE_0__.queryMetadata)(ownable_id);\n  let latestChain = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_2__.getLatestChain)(ownable_id);\n  const events = latestChain.events;\n  const modalContent = document.createElement('div');\n  modalContent.className = 'event-chain-modal';\n\n  const header = document.createElement('h2');\n  header.innerText = metadata.name;\n  const description = document.createElement('h4');\n  description.innerText = metadata.description;\n  const id = document.createElement('h5');\n  id.innerText = `ID: ${ownable_id}`;\n  modalContent.appendChild(header);\n  modalContent.appendChild(description);\n  modalContent.appendChild(id);\n\n  const eventsHeader = document.createElement('h3');\n  eventsHeader.innerText = (events.length) ? \"Events:\" : \"No events found.\";\n  modalContent.appendChild(eventsHeader);\n\n\n  for (let i = 0; i < events.length; i++) {\n    const eventJSON = events[i].toJSON();\n    const eventHTML = buildHTMLForEventDisplay(i, eventJSON);\n    let connectorDiv = document.createElement('div');\n    if (i > 0) {\n      connectorDiv = buildConnectorHTML(events[i - 1].toJSON().hash, eventJSON.previous);\n    }\n\n    connectorDiv.className = 'chain-connector';\n    modalContent.appendChild(connectorDiv);\n    modalContent.appendChild(eventHTML);\n  }\n\n  if (events.length > 0) {\n    modalContent.appendChild(buildConnectorHTML(events[events.length - 1].toJSON().hash, null));\n  }\n\n  const modal = document.getElementById('event-chain-modal');\n\n  modal.getElementsByClassName(\"modal-container\")[0].appendChild(modalContent);\n  modal.classList.add('open');\n\n  const exits = modal.querySelectorAll('.modal-bg, .close');\n  exits.forEach(function (exit) {\n    exit.addEventListener('click', function (event) {\n      event.preventDefault();\n      modal.classList.remove('open');\n      modal.getElementsByClassName(\"modal-container\")[0].removeChild(modalContent);\n    });\n  });\n}\n\n\nfunction buildConnectorHTML(hash, previous) {\n  const connectorDiv = document.createElement('div');\n  connectorDiv.className = 'chain-connector';\n\n  if (hash) {\n    const hashDiv = document.createElement('div');\n    hashDiv.className = 'connector-hash truncate';\n    hashDiv.innerHTML = `<strong>HASH:</strong><i>${hash}</i>`;\n    connectorDiv.append(hashDiv);\n  }\n\n  if (previous) {\n    const link = document.createElement('div');\n    link.className = 'connector-link';\n    link.innerHTML = '&#128279;';\n\n    const previousDiv = document.createElement('div');\n    previousDiv.className = 'connector-previous truncate';\n    previousDiv.innerHTML = `<strong>Previous:</strong><i>${previous}</i>`\n    connectorDiv.append(link, previousDiv);\n  }\n\n  return connectorDiv;\n}\n\nfunction buildHTMLForEventDisplay(index, event) {\n  const eventElement = document.createElement('div');\n  eventElement.className = `event-chain event-${index}`;\n\n  const timestamp = document.createElement('div');\n  timestamp.innerHTML = `<strong>Date: </strong><i>${new Date(event.timestamp)}</i>`;\n\n  const signature = document.createElement('div');\n  signature.className = 'truncate';\n  signature.innerHTML = `<strong>Event signature: </strong><i>${event.signature}</i>`;\n\n  const signer = document.createElement('div');\n  signer.className = 'truncate';\n  signer.innerHTML = `<strong>Signer: </strong><i>${event.signKey.publicKey}</i>`;\n\n  const mediaType = document.createElement('div');\n  mediaType.innerHTML = `<strong>Media type: </strong><i>${event.mediaType}</i>`;\n\n  const body = document.createElement('div');\n  const toggleSwitch = getToggleSwitch(index);\n  const toggleCheckbox = toggleSwitch.firstChild;\n\n  const b64 = document.createElement('div');\n  b64.innerHTML = event.data.toString();\n  b64.className = `data-b64 truncate`;\n\n  let jsonViewer = document.createElement('div');\n  let eventData = event.data.toString();\n  if (eventData.startsWith('base64:')) {\n    eventData = eventData.substring(7);\n    try {\n      eventData = JSON.parse(atob(eventData));\n      if (eventData instanceof Object) {\n        var view = new (_JSONView__WEBPACK_IMPORTED_MODULE_3___default())('body', eventData);\n        view.collapse();\n\n        jsonViewer.className = `data-json`;\n        jsonViewer.appendChild(view.dom);\n      }\n    } catch (e) {\n      console.log(\"b64 does not decode into json\");\n      jsonViewer = undefined;\n      toggleCheckbox.disabled = true;\n    }\n  }\n\n  const bodyContent = document.createElement('div');\n  bodyContent.appendChild(b64);\n\n  body.style.lineHeight = '20px';\n  body.innerHTML = `<strong>Event body</strong>:`;\n  body.appendChild(toggleSwitch);\n  body.appendChild(bodyContent);\n\n  toggleCheckbox.addEventListener('click', () => {\n    bodyContent.innerHTML = '';\n    if (toggleCheckbox.value === 'json') {\n      toggleCheckbox.value = 'b64';\n      bodyContent.appendChild(b64);\n      toggleSwitch.getElementsByClassName('b64-on')[0].style.display = 'block';\n      toggleSwitch.getElementsByClassName('json-on')[0].style.display = 'none';\n    } else if (jsonViewer !== undefined) {\n      toggleCheckbox.value = 'json';\n      bodyContent.appendChild(jsonViewer);\n      toggleSwitch.getElementsByClassName('b64-on')[0].style.display = 'none';\n      toggleSwitch.getElementsByClassName('json-on')[0].style.display = 'block';\n    }\n  });\n\n  eventElement.append(timestamp, signature, signer, mediaType, body);\n\n  return eventElement;\n}\n\nfunction getToggleSwitch(id) {\n\n  const inputElement = document.createElement('input');\n  inputElement.type = 'checkbox';\n  inputElement.id = `checkbox-id-${id}`;\n  inputElement.name = `checkbox-${id}`;\n  inputElement.value = 'b64';\n\n  const label = document.createElement('label');\n  label.htmlFor = `checkbox-id-${id}`;\n  label.className = 'switch';\n\n  const slider = document.createElement('span');\n  slider.className = 'slider round';\n  const jsonText = document.createElement('span');\n  jsonText.className = 'json-on';\n  jsonText.innerHTML = 'JSON';\n  const b64Text = document.createElement('span');\n  b64Text.className = 'b64-on';\n  b64Text.innerHTML = 'B64';\n  slider.append(jsonText, b64Text);\n\n  label.append(inputElement, slider);\n  return label;\n}\n\n\n//# sourceURL=webpack://ownable-demo/./index.js?");

/***/ }),

/***/ "./ownable-manager.js":
/*!****************************!*\
  !*** ./ownable-manager.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createNewOwnable\": () => (/* binding */ createNewOwnable),\n/* harmony export */   \"deleteOwnable\": () => (/* binding */ deleteOwnable),\n/* harmony export */   \"executeOwnable\": () => (/* binding */ executeOwnable),\n/* harmony export */   \"getAssetFromIDb\": () => (/* binding */ getAssetFromIDb),\n/* harmony export */   \"getAssetsIdb\": () => (/* binding */ getAssetsIdb),\n/* harmony export */   \"getOwnableStateDump\": () => (/* binding */ getOwnableStateDump),\n/* harmony export */   \"getOwnableTemplate\": () => (/* binding */ getOwnableTemplate),\n/* harmony export */   \"initWorker\": () => (/* binding */ initWorker),\n/* harmony export */   \"issueOwnable\": () => (/* binding */ issueOwnable),\n/* harmony export */   \"queryMetadata\": () => (/* binding */ queryMetadata),\n/* harmony export */   \"queryState\": () => (/* binding */ queryState),\n/* harmony export */   \"registerExternalEvent\": () => (/* binding */ registerExternalEvent),\n/* harmony export */   \"saveOwnableStateDump\": () => (/* binding */ saveOwnableStateDump),\n/* harmony export */   \"syncDb\": () => (/* binding */ syncDb),\n/* harmony export */   \"transferOwnable\": () => (/* binding */ transferOwnable)\n/* harmony export */ });\n/* harmony import */ var _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ltonetwork/lto/lib/events */ \"./node_modules/@ltonetwork/lto/lib/events/index.js\");\n/* harmony import */ var _event_chain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-chain */ \"./event-chain.js\");\n/* harmony import */ var _ltonetwork_lto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ltonetwork/lto */ \"./node_modules/@ltonetwork/lto/lib/index.js\");\n/* harmony import */ var _ltonetwork_lto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ltonetwork_lto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _asset_import__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asset_import */ \"./asset_import.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index */ \"./index.js\");\n/* harmony import */ var all_inline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! all-inline */ \"./node_modules/all-inline/lib/index.js\");\n/* harmony import */ var all_inline__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(all_inline__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _ltonetwork_lto_lib_utils_crypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ltonetwork/lto/lib/utils/crypto */ \"./node_modules/@ltonetwork/lto/lib/utils/crypto.js\");\n\n\n\n\n\n\n\n\nconst lto = new _ltonetwork_lto__WEBPACK_IMPORTED_MODULE_2__.LTO('T');\n\nfunction clearOwnableFrames() {\n  const grid = document.getElementsByClassName(\"grid-container\")[0];\n  while (grid.firstChild) {\n    grid.removeChild(grid.firstChild);\n  }\n}\n\nasync function createOwnableFrame(ownableId, ownableType) {\n  if (document.getElementById(ownableId)) throw new Error(`Ownable iframe for ${ownableId} already exists`);\n\n  const ownableGrid = document.getElementsByClassName(\"grid-container\")[0];\n  ownableGrid.appendChild(await generateOwnable(ownableId, ownableType));\n\n  return document.getElementById(ownableId);\n}\n\nfunction getOwnableFrame(ownableId) {\n  const frame = document.getElementById(ownableId);\n  if (!frame) throw new Error(`Ownable iframe ${ownableId} doesn't exist`);\n\n  return frame;\n}\n\nasync function postToOwnableFrame(ownableId, msg) {\n  return new Promise(resolve => {\n    const ownableIframe = getOwnableFrame(ownableId);\n    window.addEventListener('message', (e) => {\n      resolve(e.data);\n    }, {once: true});\n    ownableIframe.contentWindow.postMessage(msg, \"*\");\n  });\n}\n\nasync function initWorker(ownableId, ownableType) {\n  const bindgenDataURL = await readBindgenAsDataURL(ownableType);\n  const gluedBindgenDataURL = await appendWorkerToBindgenDataURL(bindgenDataURL);\n\n  const wasmArrayBuffer = await getBlobFromObjectStoreAsArrayBuffer(ownableType, \"wasm\");\n  const b64WASM = btoa(\n    new Uint8Array(wasmArrayBuffer)\n      .reduce((data, byte) => data + String.fromCharCode(byte), '')\n  );\n\n  const msg = {\n    method: 'initWorker',\n    args: [\n      ownableId,\n      gluedBindgenDataURL,\n      b64WASM,\n    ],\n  };\n\n  return postToOwnableFrame(ownableId, msg);\n}\n\nfunction appendWorkerToBindgenDataURL(bindgenDataURL) {\n  return new Promise(async (resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = () => {\n      const dataURLSeparator = 'base64,';\n      const bindgenString = bindgenDataURL.split(dataURLSeparator);\n      let newBindgenContents = fr.result + \"\\n\" + atob(bindgenString[1]);\n      resolve(newBindgenContents);\n    };\n    let workerGlue = await fetch(\"./ownable-worker.js\");\n    let blob = await workerGlue.blob();\n    fr.readAsText(blob);\n  });\n}\n\nfunction readBindgenAsDataURL(objectStore) {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(_event_chain__WEBPACK_IMPORTED_MODULE_1__.ASSETS_STORE);\n    let db;\n\n    request.onsuccess = async () => {\n      db = request.result;\n      const tx = db.transaction([objectStore], \"readonly\")\n        .objectStore(objectStore);\n      let bindgen = tx.get(\"bindgen.js\");\n      bindgen.onsuccess = async (e) => {\n        const fr = new FileReader();\n        fr.onloadend = () => {\n          db.close()\n          resolve(fr.result);\n        };\n        fr.readAsDataURL(bindgen.result);\n      }\n      bindgen.onerror = (e) => reject(e);\n    }\n    request.onblocked = (event) => reject(\"idb blocked: \", event);\n    request.onerror = (event) => reject(\"failed to open indexeddb: \", event.errorCode);\n  });\n}\n\nfunction getBlobFromObjectStoreAsArrayBuffer(objectStore, type) {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(_event_chain__WEBPACK_IMPORTED_MODULE_1__.ASSETS_STORE);\n    let db;\n\n    request.onsuccess = async () => {\n      db = request.result;\n      const tx = db.transaction([objectStore], \"readonly\")\n        .objectStore(objectStore);\n      let wasm_file = tx.get(type);\n      wasm_file.onsuccess = async (e) => {\n        const fr = new FileReader();\n        fr.onload = () => {\n          db.close();\n          resolve(fr.result);\n        };\n        fr.readAsArrayBuffer(e.target.result);\n      }\n      wasm_file.onerror = (e) => reject(e);\n    }\n    request.onblocked = (event) => reject(\"idb blocked: \", event);\n    request.onerror = (event) => reject(\"failed to open indexeddb: \", event.errorCode);\n  });\n}\n\nfunction getAccount() {\n  let existingSeed = localStorage.encryptedSeed;\n  let account;\n  if (existingSeed === undefined) {\n    const phrase = window.prompt(\"import seed phrase\", \"\");\n    const pw = window.prompt(\"Setup a password for your account\", \"\");\n    if (phrase === \"\") {\n      account = lto.account();\n    } else {\n      let accountFactory = new _ltonetwork_lto__WEBPACK_IMPORTED_MODULE_2__.AccountFactoryED25519('T');\n      account = accountFactory.createFromSeed(phrase);\n    }\n    localStorage.encryptedSeed = account.encryptSeed(pw);\n  } else {\n    account = attemptToDecryptSeed(existingSeed);\n  }\n  return account;\n}\n\nfunction attemptToDecryptSeed(seed, promptMsg = \"Enter your password\") {\n  let account;\n  while (account === undefined) {\n    const pw = window.prompt(promptMsg, \"\");\n    const settings = {\n      seed: seed,\n      seedPassword: pw,\n    };\n    try {\n      account = lto.account(settings);\n      return account;\n    } catch (e) {\n      promptMsg = \"Invalid password, try again\";\n    }\n  }\n}\n\nfunction getMessageInfo() {\n  return {\n    sender: account.address,\n    funds: [],\n  }\n}\n\nasync function executeOwnable(ownable_id, msg) {\n  const state_dump = await getOwnableStateDump(ownable_id);\n\n  const workerMsg = {\n    type: \"execute\",\n    ownable_id: ownable_id,\n    msg: msg,\n    info: getMessageInfo(),\n    idb: state_dump,\n  };\n\n  const postMsg = {\n    method: 'executeOwnable',\n    args: [\n      ownable_id,\n      workerMsg,\n    ],\n  };\n\n  const data = await postToOwnableFrame(ownable_id, postMsg);\n  const state = JSON.parse(data.get('state'));\n  const isExternalEvent = state.attributes.find(a => a.key === 'external_event');\n  let externalEvent = undefined;\n  if (isExternalEvent) {\n    externalEvent = JSON.parse(atob(state.data));\n  }\n\n  const mem = JSON.parse(data.get('mem'));\n\n  let db = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.initIndexedDb)(ownable_id);\n  await saveOwnableStateDump(db, mem);\n  db.close();\n\n  await queryState(ownable_id);\n\n  const newEvent = new _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__.Event({\"@context\": \"execute_msg.json\", ...msg});\n  const latestChain = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.getLatestChain)(ownable_id);\n  await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.anchorEventToChain)(latestChain, newEvent, lto.node, account);\n  await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.writeLatestChain)(ownable_id, latestChain);\n  return externalEvent;\n}\n\nasync function registerExternalEvent(ownable_id, msg) {\n  const state_dump = await getOwnableStateDump(ownable_id);\n  const workerMsg = {\n    type: \"external_event\",\n    ownable_id: ownable_id,\n    msg: msg,\n    info: getMessageInfo(),\n    idb: state_dump,\n  };\n\n  const postMsg = {\n    method: 'registerExternalEvent',\n    args: [\n      ownable_id,\n      workerMsg,\n    ],\n  };\n  window.alert(`posting to iframe ${ownable_id}, ${JSON.stringify(postMsg)}`);\n  const data = await postToOwnableFrame(ownable_id, postMsg);\n  const state = JSON.parse(data.get('state'));\n  window.alert(`response state: ${JSON.stringify(state)}`);\n\n  const mem = JSON.parse(data.get('mem'));\n\n  let db = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.initIndexedDb)(ownable_id);\n  await saveOwnableStateDump(db, mem);\n  db.close();\n\n  await queryState(ownable_id);\n\n  const newEvent = new _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__.Event({\"@context\": \"register_external_event.json\", ...msg});\n  const latestChain = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.getLatestChain)(ownable_id);\n  const anchor = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.anchorEventToChain)(latestChain, newEvent, lto.node, account);\n  await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.writeLatestChain)(ownable_id, latestChain);\n  console.log(\"anchor: \", anchor);\n}\n\nasync function deleteOwnable(ownable_id) {\n  await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.deleteIndexedDb)(ownable_id);\n  localStorage.removeItem(ownable_id);\n  setTimeout(() => {}, 500);\n  await syncDb();\n}\n\nasync function queryState(ownable_id) {\n  const state_dump = await getOwnableStateDump(ownable_id);\n\n  return new Promise(async (resolve, reject) => {\n    let msg = {\n      \"get_ownable_config\": {},\n    };\n\n    const queryMsg = {\n      method: \"queryState\",\n      args: [\n        ownable_id,\n        msg,\n        state_dump,\n      ],\n    };\n    let resp = await postToOwnableFrame(ownable_id, queryMsg);\n\n    const stateMap = JSON.parse(resp.get('state'));\n    const state = JSON.parse(atob(stateMap));\n    console.log('state queried: ', state);\n    resolve(state);\n  });\n\n}\n\nfunction queryMetadata(ownable_id) {\n  return new Promise(async (resolve, reject) => {\n    const state_dump = await getOwnableStateDump(ownable_id);\n    const ownableIframe = document.getElementById(ownable_id);\n\n    let msg = {\n      \"get_ownable_metadata\": {},\n    };\n\n    const workerMsg = {\n      method: \"queryMetadata\",\n      args: [\n        ownable_id,\n        msg,\n        state_dump,\n      ],\n    };\n\n    let resp = await postToOwnableFrame(ownable_id, workerMsg);\n    const metadataString = atob(JSON.parse(resp.get('state')));\n    const metadata = JSON.parse(metadataString);\n    resolve(metadata);\n    // ownableIframe.contentWindow.postMessage(workerMsg, \"*\");\n  })\n}\n\nasync function issueOwnable(ownableType, chain) {\n  const msg = {\n    ownable_id: chain.id,\n  };\n\n  const workerMsg = {\n    method: \"issueOwnable\",\n    args: [\n      msg.ownable_id,\n      msg,\n      getMessageInfo(),\n    ],\n  };\n\n  const data = await postToOwnableFrame(chain.id, workerMsg);\n  const state = JSON.parse(data.get('state'));\n  const mem = JSON.parse(data.get('mem'));\n\n  return {mem, state, msg};\n}\n\nasync function createNewOwnable(templateName) {\n  const chain = _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__.EventChain.create(account);\n  await createOwnableFrame(chain.id, templateName);\n\n  await initWorker(chain.id, templateName);\n  const {mem, msg} = await issueOwnable(templateName, chain);\n\n  let db = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.initIndexedDb)(chain.id);\n  await saveOwnableStateDump(db, mem);\n\n  await (0,_asset_import__WEBPACK_IMPORTED_MODULE_3__.associateOwnableType)(db, chain.id, templateName);\n  reflectOwnableIssuanceInLocalStore(chain.id, templateName);\n\n  let newEvent = new _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__.Event({\"@context\": \"instantiate_msg.json\", ...msg});\n  await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.anchorEventToChain)(chain, newEvent, lto.node, account);\n  await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.writeInstantiatedChainToIdb)(db, chain);\n  db.close();\n}\n\nasync function instantiateOwnable(ownableId) {\n  const ownableType = localStorage.getItem(ownableId);\n  await createOwnableFrame(ownableId, ownableType);\n  await initWorker(ownableId, ownableType);\n\n  await queryState(ownableId); // Query state refreshes the widget within the ownable iframe\n}\n\nasync function getInstantiateSchema(templateName) {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(\"assets\");\n    request.onblocked = (event) => reject(\"idb blocked: \", event);\n    request.onerror = (event) => reject(\"failed to open indexeddb: \", event.errorCode);\n    request.onupgradeneeded = (event) => {\n      if (!request.result.objectStoreNames.contains(templateName)) {\n        reject(\"no such object store\");\n      }\n    }\n    request.onsuccess = async () => {\n      let db = request.result;\n      const objectStore = db.transaction(templateName, \"readonly\").objectStore(templateName);\n      const txn = objectStore.get(\"instantiate_msg.json\");\n      txn.onsuccess = () => {\n        const fr = new FileReader();\n        fr.onloadend = () => {\n          db.close()\n          resolve(fr.result);\n        };\n        fr.readAsText(txn.result);\n      }\n      txn.onerror = (e) => reject(e);\n    };\n  });\n}\n\nfunction reflectOwnableIssuanceInLocalStore(ownableId, ownableType) {\n  // associate the type\n  localStorage.setItem(ownableId, ownableType);\n  console.log(\"setting ownable id type\", ownableId, ownableType)\n  // add to the list of existing chain ids\n  let chainIds = JSON.parse(localStorage.chainIds);\n  chainIds.push(ownableId);\n  localStorage.chainIds = JSON.stringify(chainIds);\n}\n\nasync function saveOwnableStateDump(db, mem) {\n  return new Promise(async (resolve, reject) => {\n    const memSlots = mem['state_dump'];\n    for (let i = 0; i < memSlots.length; i++) {\n      const slot = memSlots[i];\n      await writeStateDumpPair(db, slot[0], slot[1]);\n    }\n    resolve();\n  });\n}\n\nfunction writeStateDumpPair(db, key, val){\n  return new Promise((resolve, reject) => {\n    let txn = db.transaction(\"state\", \"readwrite\").objectStore(\"state\");\n    let resp = txn.put(val, key);\n    resp.onsuccess = () => resolve(resp.result);\n    resp.onerror = (e) => reject(e);\n  });\n}\n\nasync function getOwnableStateDump(ownable_id) {\n  return new Promise(async (resolve, reject) => {\n    let respObj = {\n      \"state_dump\": [],\n    };\n\n    const keys = await getStateDumpKeys(ownable_id);\n    let db = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.initIndexedDb)(ownable_id);\n\n    for (let i = 0; i < keys.length; i++) {\n      let txn = db.transaction(\"state\", \"readonly\").objectStore(\"state\");\n      let state_dump_entry = await getIdbStateDumpEntry(txn, keys[i]);\n      respObj.state_dump.push(state_dump_entry);\n    }\n    db.close();\n    resolve(respObj);\n  });\n}\n\nfunction getStateDumpKeys(ownable_id) {\n  return new Promise(async (resolve, reject) => {\n    let db = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.initIndexedDb)(ownable_id);\n    let txn = db.transaction(\"state\", \"readonly\").objectStore(\"state\");\n    let resp = txn.getAllKeys();\n    resp.onsuccess = () => resolve(resp.result);\n    resp.onerror = (e) => reject(e);\n  });\n}\n\nfunction getIdbStateDumpEntry(txn, key) {\n  return new Promise((resolve, reject) => {\n    let resp = txn.get(key);\n    resp.onsuccess = () => {\n      let state_dump_entry = [key, resp.result];\n      resolve(state_dump_entry);\n    };\n    resp.onerror = (e) => reject(e);\n  });\n}\n\nasync function syncDb() {\n  return new Promise(async (resolve, reject) => {\n    if (!localStorage.chainIds) {\n      reject();\n    }\n    console.log('syncing ownables')\n    clearOwnableFrames();\n\n    const chainIds = JSON.parse(localStorage.chainIds);\n    console.log(\"chain ids:\", chainIds)\n    return Promise.all(chainIds.map(instantiateOwnable));\n  });\n}\n\nasync function getAssetsIdb(templateName) {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(\"assets\");\n    request.onblocked = (event) => reject(\"idb blocked: \", event);\n    request.onerror = (event) => reject(\"failed to open indexeddb: \", event.errorCode);\n    request.onupgradeneeded = (event) => {\n      if (!request.result.objectStoreNames.contains(templateName)) {\n        request.result.createObjectStore(templateName);\n      }\n    }\n    request.onsuccess = async () => {\n      let db = request.result;\n      resolve(db);\n    };\n  });\n}\n\nasync function getAssetFromIDb(currentSrc, db, templateName, callback) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    // query the idb for that media and update the template\n    console.log(templateName)\n    ;(0,_asset_import__WEBPACK_IMPORTED_MODULE_3__.fetchTemplate)(db, currentSrc, templateName).then(mediaFile => {\n      if (!mediaFile) {\n        resolve();\n      }\n      fr.onload = (event) => {\n        resolve(event.target.result);\n      };\n      callback(fr, mediaFile);\n    }, error => reject(error));\n  });\n}\n\nfunction getOwnableTemplate(ownableType) {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(_event_chain__WEBPACK_IMPORTED_MODULE_1__.ASSETS_STORE);\n    const reader = new FileReader();\n    let db, template;\n    request.onblocked = (event) => reject(\"idb blocked: \", event);\n    request.onerror = (event) => reject(\"failed to open indexeddb: \", event.errorCode);\n    request.onsuccess = async () => {\n      db = request.result;\n      template = await (0,_asset_import__WEBPACK_IMPORTED_MODULE_3__.fetchTemplate)(db, \"html\", ownableType);\n      reader.onload = function(evt) {\n        db.close();\n        resolve(`${evt.target.result}`);\n      };\n      reader.readAsText(template);\n    };\n  });\n}\n\nasync function generateOwnableInner(ownable_id, type) {\n  // generate iframe contents\n  const ownableContent = document.createElement('div');\n  ownableContent.innerHTML = await getOwnableTemplate(type);\n  ownableContent.style.height = \"100%\";\n\n  const db = await getAssetsIdb(type);\n  await all_inline__WEBPACK_IMPORTED_MODULE_5___default()(ownableContent, async (source, encoding) => {\n    if (encoding === 'data-uri') {\n      return getAssetFromIDb(source, db, type, (fr, mediaFile) => fr.readAsDataURL(mediaFile));\n    } else if (encoding === 'text') {\n      return getAssetFromIDb(source, db, type, (fr, mediaFile) => fr.readAsText(mediaFile));\n    } else {\n      throw Error(`Unsupported encoding ${encoding} of asset ${source}`);\n    }\n  });\n  db.close();\n\n  // generate widget iframe\n  const ownableWidget = document.createElement('iframe');\n  ownableWidget.id = ownable_id;\n  ownableWidget.sandbox = \"allow-scripts\";\n  ownableWidget.srcdoc = ownableContent.outerHTML;\n\n  const ownableScript = document.createElement('script');\n  ownableScript.src = './ownable.js';\n\n  const ownableStyle = document.createElement('style');\n  ownableStyle.innerHTML = `\n    html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; }\n    iframe { height: 100%; width: 100%; border: none; }\n  `;\n\n  const ownableBody = document.createElement('body');\n  ownableBody.appendChild(ownableStyle)\n  ownableBody.appendChild(ownableWidget);\n  ownableBody.appendChild(ownableScript);\n\n  // takes source and encoding {source: string, encoding: 'text'|'data-uri'}\n  // returns a promise of a string/null\n  let contents = await all_inline__WEBPACK_IMPORTED_MODULE_5___default()(ownableBody, async (src, type) => {\n\n  });\n  return ownableBody.outerHTML;\n}\n\nasync function generateOwnable(ownable_id, type) {\n  // generate iframe, set contents\n  const ownableIframe = document.createElement('iframe');\n  ownableIframe.id = ownable_id;\n  ownableIframe.srcdoc = await generateOwnableInner(ownable_id, type);\n\n  // wrap iframe in a grid-item and return\n  const ownableElement = document.createElement('div');\n  ownableElement.style.position = \"relative\";\n  ownableElement.classList.add('ownable');\n  ownableElement.appendChild(getOwnableActionsHTML(ownable_id));\n  ownableElement.appendChild(getOwnableDragHandle());\n  ownableElement.appendChild(ownableIframe);\n\n  setOwnableDragDropEvent(ownableElement, ownable_id);\n\n  // wrap iframe in a grid-item and return\n  const ownableGridItem = document.createElement('div');\n  ownableGridItem.classList.add('grid-item');\n  ownableGridItem.appendChild(ownableElement);\n\n  return ownableGridItem;\n}\n\nfunction getOwnableActionsHTML(ownable_id) {\n\n  const generalActions = document.createElement(\"div\");\n  generalActions.className = \"general-actions\";\n\n\n  const transferButton = document.createElement(\"button\");\n  transferButton.id = \"transfer-button\";\n  transferButton.textContent = \"Transfer\";\n  transferButton.addEventListener(\n    'click',\n    async () => {\n      await transferOwnable(ownable_id);\n      generalActions.style.display = \"none\";\n    }\n  );\n\n  const deleteButton = document.createElement(\"button\");\n  deleteButton.id = \"delete-button\";\n  deleteButton.textContent = \"Delete\";\n  deleteButton.addEventListener(\n    'click',\n    async () => {\n      await deleteOwnable(ownable_id);\n      generalActions.style.display = \"none\";\n    }\n  );\n\n  const infoButton = document.createElement(\"button\");\n  infoButton.id = \"info-button\";\n  infoButton.textContent = \"Info\";\n  infoButton.addEventListener(\n    'click',\n    async () => {\n      await (0,_index__WEBPACK_IMPORTED_MODULE_4__.getOwnableInfo)(ownable_id);\n      generalActions.style.display = \"none\";\n    }\n  );\n\n\n  generalActions.appendChild(transferButton);\n  generalActions.appendChild(deleteButton);\n  generalActions.appendChild(infoButton);\n\n  const threeDots = document.createElement(\"div\");\n  threeDots.className = \"three-dots\";\n  threeDots.id = \"more-button\";\n  // threeDots.addEventListener(\n  //   'mouseover',\n  //   () => { generalActions.style.display = \"flex\"\n  // });\n  // threeDots.addEventListener(\n  //   'touchstart',\n  //   () => { generalActions.style.display = \"flex\"\n  // });\n  // threeDots.addEventListener(\n  //   'mouseout',\n  //   () => { generalActions.style.display = \"none\"\n  // });\n  // threeDots.addEventListener(\n  //   'touchend',\n  //   () => { generalActions.style.display = \"none\"\n  // });\n\n  threeDots.addEventListener('click', () => { generalActions.style.display = \"flex\" });\n\n  threeDots.appendChild(generalActions);\n\n  return threeDots;\n}\n\nfunction getOwnableDragHandle() {\n  const handle = document.createElement('div');\n  handle.style.height = '25px';\n  handle.classList.add('drag-handle');\n  handle.addEventListener('mousedown', (e) => {\n    e.target.parentNode.setAttribute('draggable', 'true');\n  });\n  handle.addEventListener('touchstart', (e) => {\n    e.target.parentNode.setAttribute('draggable', 'true');\n  });\n  handle.addEventListener('mouseup', (e) => {\n    e.target.parentNode.setAttribute('draggable', 'false')\n  });\n  handle.addEventListener('touchend', (e) => {\n    e.target.parentNode.setAttribute('draggable', 'false')\n  });\n\n  return handle;\n}\n\nfunction setOwnableDragDropEvent(ownableElement, ownable_id) {\n\n  ownableElement.addEventListener('dragstart', (e) => handleDragBeginEvent(e, ownable_id, true));\n  ownableElement.addEventListener('touchstart', (e) => handleDragBeginEvent(e, ownable_id, true));\n\n  ownableElement.addEventListener('dragend', (e) => {\n    e.target.style.opacity = '';\n    document.querySelectorAll('.ownables-grid .dropzone').forEach(el => el.style.display = 'none');\n  });\n\n  ownableElement.addEventListener('dragover', (e) => {\n    e.preventDefault(); // Allow drop\n  });\n\n  ownableElement.addEventListener('drop', async (e) => await handleConsumptionEvent(e, ownable_id, true));\n  ownableElement.addEventListener('touchend', async (e) => {\n    e.target.style.opacity = '';\n    document.querySelectorAll('.ownables-grid .dropzone')\n      .forEach(el => el.style.display = 'none');\n    await handleConsumptionEvent(e, ownable_id, true);\n  }, { once: true },);\n\n  const dropZone = document.createElement(\"div\");\n  dropZone.classList.add('dropzone');\n  dropZone.style.display = 'none';\n  ownableElement.appendChild(dropZone);\n}\n\nasync function handleDragBeginEvent(e, ownable_id, touchscreen) {\n  e.target.style.opacity = '0.4';\n  console.log('handleDragBeginEvent: ', e);\n  if (!touchscreen) {\n    e.dataTransfer.setData(\"application/json\", JSON.stringify({ownable_id}));\n  } else {\n    e.target.id = JSON.stringify({ownable_id});\n    console.log(e);\n  }\n  document.querySelectorAll('.ownables-grid .dropzone')\n    .forEach(el => el.style.display = '');\n}\n\nasync function handleConsumptionEvent(e, source_ownable_id, touchscreen) {\n  let target_ownable_id = \"\";\n  if (!touchscreen) {\n    target_ownable_id = JSON.parse(e.dataTransfer.getData(\"application/json\"));\n    console.log(\"data transfer event, target ownable id: \", target_ownable_id);\n  } else {\n    const touch = e.touches[0] || e.changedTouches[0];\n    console.log('consumption event: ', e);\n    const x = touch.pageX || e.pageX;\n    const y = touch.pageY || e.pageY;\n    const dropZone = document.elementFromPoint(x, y);\n    window.alert(`x: ${x}, y: ${y}`);\n    window.alert(dropZone.id);\n    console.log('dropzone: ', dropZone.innerHTML);\n    console.log(dropZone.id);\n    if (dropZone.id['ownable_id'] !== undefined) {\n      target_ownable_id = dropZone.id['ownable_id'];\n    } else {\n      target_ownable_id = dropZone.id;\n    }\n  }\n\n  console.log(\"target ownable id: \", target_ownable_id);\n  console.log(\"source ownable id: \", source_ownable_id);\n\n  if (target_ownable_id !== source_ownable_id) {\n    window.alert(`consumable id: ${source_ownable_id} \\n consumer id: ${target_ownable_id}`);\n    // TODO This should be atomic. If the ownable can't consume, the consumable shouldn't be consumed.\n    if (target_ownable_id['ownable_id'] !== undefined) {\n      target_ownable_id = target_ownable_id['ownable_id'];\n      console.log('cleaning target event: ', target_ownable_id);\n    } else {\n      console.log('target event: ', target_ownable_id);\n    }\n    const externalEvent = JSON.parse(await executeOwnable(source_ownable_id, {consume: {}}));\n    console.log(\"external event returned from consumable: \", externalEvent);\n    setTimeout(() => {\n      console.log('pausing');\n    }, 1000);\n    await registerExternalEvent(target_ownable_id, externalEvent);\n  } // Can't consume self\n}\n\nasync function transferOwnable(ownable_id) {\n  let addr = window.prompt(\"Transfer the Ownable to: \", null);\n\n  if (!lto.isValidAddress(addr)) {\n    alert(`${addr} is not a valid address`);\n    return;\n  }\n\n  let metadata = await queryMetadata(ownable_id);\n\n  if (confirm(`Are you sure you want to transfer the ownership of this ${metadata.name} ownable to ${addr}?`)) {\n    const chainMessage = {\n      transfer: {\n        to: addr,\n      },\n    };\n\n    const state_dump = await getOwnableStateDump(ownable_id);\n    let workerMessage = {\n      method: \"transferOwnable\",\n      args: [\n        ownable_id,\n        chainMessage,\n        getMessageInfo(),\n        state_dump,\n      ],\n    };\n\n    await postToOwnableFrame(ownable_id, workerMessage);\n\n    const newEvent = new _ltonetwork_lto_lib_events__WEBPACK_IMPORTED_MODULE_0__.Event({\"@context\": \"execute_msg.json\", ...chainMessage});\n    const eventChain = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.getLatestChain)(ownable_id);\n    let mappedAnchor = await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.anchorEventToChain)(eventChain, newEvent, lto.node, account);\n    await (0,_event_chain__WEBPACK_IMPORTED_MODULE_1__.writeLatestChain)(ownable_id, eventChain);\n    console.log(\"mappedAnchor:\", mappedAnchor);\n  }\n}\n\n// Todo I want to be moved\nlet account = getAccount();\n\n\n//# sourceURL=webpack://ownable-demo/./ownable-manager.js?");

/***/ }),

/***/ "?8131":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/buffer_(ignored)?");

/***/ }),

/***/ "?3fc0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/crypto_(ignored)?");

/***/ }),

/***/ "?f9d4":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/buffer_(ignored)?");

/***/ }),

/***/ "?7a28":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/buffer_(ignored)?");

/***/ }),

/***/ "?cad2":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/util_(ignored)?");

/***/ }),

/***/ "?593c":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/util_(ignored)?");

/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/crypto_(ignored)?");

/***/ }),

/***/ "?3e83":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/util_(ignored)?");

/***/ }),

/***/ "?19e6":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/util_(ignored)?");

/***/ }),

/***/ "?dba7":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ownable-demo/crypto_(ignored)?");

/***/ })

}]);